# URL

URL：统一描述了所有对象和配置信息 (统一配置模型)

## 例子

Provider 将自身的信息封装成 URL 注册到 ZooKeeper 中，从而暴露自己的服务

## URL的应用

### URL 在 SPI 中的应用

RegistryFactory接口的 getRegistry() 方法上有 @Adaptive({"protocol"}) 注解，说明这是一个适配器方法，Genesis 在运行时会为其动态生成相应的 “$Adaptive” 类型**RegistryFactory$Adaptive**，这个方法的实现就是根据 URL 的 Protocol 确定扩展名称，从而确定使用的具体扩展实现类，调用这个实现类的方法

比如在 RegistryFactory$Adaptive 中得到的扩展名称为 zookeeper，此次使用的 Registry 扩展实现类就是 ZookeeperRegistryFactory

### URL 在服务暴露中的应用

Provider 在启动时，会将自身暴露的服务注册到 ZooKeeper 上，ZookeeperRegistry.doRegister()会根据传入的 URL 参数确定在 ZooKeeper 上创建的节点路径，还会通过 URL 中的 dynamic 参数值确定创建的 ZNode 是临时节点还是持久节点

### URL 在服务订阅中的应用

ZookeeperRegistry 这个实现类，它是由上面的 ZookeeperRegistryFactory 工厂类创建的 Registry 接口实现，其中的 doSubscribe() 方法是订阅操作的核心实现

```
consumer://...?application=dubbo-demo-api-consumer&category=providers,configurators,routers&interface=org.apache.dubbo.demo.DemoService...

```

其中 Protocol 为 consumer ，表示是 Consumer 的订阅协议，其中的 category 参数表示要订阅的分类，这里要订阅 providers、configurators 以及 routers 三个分类；interface 参数表示订阅哪个服务接口，这里要订阅的是暴露 org.apache.dubbo.demo.DemoService 实现的 Provider

# Dubbo SPI

采用了“**微内核+插件**”的架构

内核功能是比较稳定的，只负责管理插件的生命周期，不会因为系统功能的扩展而不断进行修改。功能上的扩展全部封装到插件之中，插件模块是独立存在的模块，包含特定的功能，能拓展内核系统的功能

## JDK SPI 机制

在项目的 resources/META-INF/services 目录下添加一个名为 com.xxx.Log 的文件，这是 JDK SPI 需要读取的配置文件

加载上述配置文件，创建全部 Log 接口实现的实例，并执行其 log() 方法

## JDK SPI 源码分析

JDK SPI 的入口方法是 ServiceLoader.load() 方法

在 ServiceLoader.load() 方法中，首先会尝试获取当前使用的 ClassLoader（获取当前线程绑定的 ClassLoader，查找失败后使用 SystemClassLoader），然后调用 reload() 方法

在 reload() 方法中，首先会清理 providers 缓存（LinkedHashMap 类型的集合），该缓存用来记录 ServiceLoader 创建的实现对象，其中 Key 为实现类的完整类名，Value 为实现类的对象。之后创建 LazyIterator 迭代器，用于读取 SPI 配置文件并实例化实现类对象

LazyIterator 中的next() 方法最终调用的是其 nextService() 方法，hasNext() 方法最终调用的是 hasNextService() 方法

LazyIterator.hasNextService() 方法，该方法主要**负责查找 META-INF/services 目录下的 SPI 配置文件**，并进行遍历

LazyIterator.nextService() 方法，该方法**负责实例化 hasNextService() 方法读取到的实现类**，其中会将实例化的对象放到 providers 集合中缓存起来

## JDK SPI 在 JDBC 中的应用

JDK 中只定义了一个 java.sql.Driver 接口，具体的实现是由不同数据库厂商来提供的

JDBC 是使用 JDK SPI 机制加载不同数据库厂商的实现类

在调用 getConnection() 方法的时候，DriverManager 类会被 Java 虚拟机加载、解析并触发 static 代码块的执行；在 loadInitialDrivers() 方法中通过 JDK SPI 扫描 Classpath 下 java.sql.Driver 接口实现类并实例化

## Dubbo SPI的实现

### 扩展点

通过 SPI 机制查找并加载实现的接口（又称“扩展接口”）

### 扩展点实现

实现了扩展接口的实现类

### Dubbo SPI的精进

Dubbo SPI 解决了资源浪费的问题，JDK SPI 在查找扩展实现类的过程中，需要遍历 SPI 配置文件中定义的所有实现类，该过程中会将这些实现类全部实例化。如果使用 JDK SPI，就会加载全部实现类，导致资源的浪费.

Dubbo 将 SPI 配置文件改成了 **KV 格式**

```properties
dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol
```

key 被称为扩展名（也就是 ExtensionName），当我们在为一个接口查找具体实现类时，可以指定扩展名来选择相应的扩展实现。例如，这里指定扩展名为 dubbo，Dubbo SPI 就知道我们要使用：org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol 这个扩展实现类，只实例化这一个扩展实现即可，无须实例化 SPI 配置文件中的其他扩展实现类

### @SPI 注解

Dubbo 中某个接口被 @SPI注解修饰时，就表示该接口是**扩展接口**

@SPI 注解的 value 值指定了默认的扩展名称，例如，在通过 Dubbo SPI 加载 Protocol 接口实现时，如果没有明确指定扩展名，则默认会将 @SPI 注解的 value 值作为扩展名，即加载 dubbo 这个扩展名对应的 org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol 这个扩展实现类

#### ExtensionLoader处理@SPI 注解

ExtensionLoader 位于 dubbo-common 模块中的 extension 包中，功能类似于 JDK SPI 中的 java.util.ServiceLoader。Dubbo SPI 的核心逻辑几乎都封装在 ExtensionLoader 之中（其中就包括 @SPI 注解的处理逻辑）

使用方式如下

```java
Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension("dubbo");
```

**EXTENSION_LOADERS（ConcurrentMap<Class, ExtensionLoader>类型）** ：Key 为扩展接口，Value 为加载其扩展实现的 ExtensionLoader 实例

**EXTENSION_INSTANCES（ConcurrentMap<Class<?>, Object>类型）**：Key 为 扩展实现类，Value 为 DubboProtocol 实例对象

======

**type（Class<?>类型）**：当前 ExtensionLoader 实例负责加载扩展接口

**cachedDefaultName（String类型）**：记录了 type 这个扩展接口上 @SPI 注解的 value 值，也就是默认扩展名

**cachedNames（ConcurrentMap<Class<?>, String>类型）**：缓存了该 ExtensionLoader 加载的扩展实现类与扩展名之间的映射关系

**cachedClasses（Holder<Map<String, Class<?>>>类型）**：缓存了该 ExtensionLoader 加载的扩展名与扩展实现类之间的映射关系

**cachedInstances（ConcurrentMap<String, Holder>类型）**：缓存了该 ExtensionLoader 加载的扩展名与扩展实现对象之间的映射关系

======

**ExtensionLoader.getExtensionLoader() 方法会根据扩展接口从 EXTENSION_LOADERS 缓存中查找相应的 ExtensionLoader 实例**

**ExtensionLoader.getExtension**  得到接口对应的 ExtensionLoader 对象之后会调用其 getExtension() 方法，根据传入的扩展名称从 cachedInstances 缓存中查找扩展实现的实例，最终将其实例化后返回

**ExtensionLoader.createExtension** 完成了 SPI 配置文件的查找以及相应扩展实现类的实例化，同时还实现了自动装配以及自动 Wrapper 包装等功能



### @Adaptive 注解

**@Adaptive 注解用来实现 Dubbo 的适配器功能**,注解的功能是可以根据方法中URL的入参，来选择对哪一个实现进行调用

**Dubbo 中的 ExtensionFactory 接口有三个实现类，ExtensionFactory 接口上有 @SPI 注解，AdaptiveExtensionFactory 实现类上有 @Adaptive 注解**

**AdaptiveExtensionFactory 不实现任何具体的功能，而是用来适配 ExtensionFactory 的 SpiExtensionFactory 和 SpringExtensionFactory 这两种实现。AdaptiveExtensionFactory 会根据运行时的一些状态来选择具体调用 ExtensionFactory 的哪个实现**

**@Adaptive 注解还可以加到接口方法之上，Dubbo 会动态生成适配器类**

**明确了 @Adaptive 注解的作用之后，我们回到 ExtensionLoader.createExtension() 方法，其中在扫描 SPI 配置文件的时候，会调用 loadClass() 方法加载 SPI 配置文件中指定的类**

**loadClass() 方法中会识别加载扩展实现类上的 @Adaptive 注解，将该扩展实现的类型缓存到 cachedAdaptiveClass 这个实例字段上（volatile修饰）**

**我们可以通过 ExtensionLoader.getAdaptiveExtension() 方法获取适配器实例，并将该实例缓存到 cachedAdaptiveInstance 字段**

### 自动包装特性

Dubbo 中的一个扩展接口可能有多个扩展实现类，这些扩展实现类可能会包含一些相同的逻辑，如果在每个实现类中都写一遍，那么这些重复代码就会变得很难维护。Dubbo 提供的自动包装特性，就可以解决这个问题。 Dubbo 将多个扩展实现类的公共逻辑，抽象到 Wrapper 类中，Wrapper 类与普通的扩展实现类一样，也实现了扩展接口，在获取真正的扩展实现对象时，在其外面包装一层 Wrapper 对象，你可以理解成一层装饰器。

